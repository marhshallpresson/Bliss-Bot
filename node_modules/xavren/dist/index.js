"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = void 0;
const fs_1 = __importDefault(require("fs"));
const chokidar_1 = __importDefault(require("chokidar"));
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config();
const utils_1 = require("./utils");
const state_1 = require("./state");
const websocket_1 = require("./websocket");
function watchEnv({ filePath = ".env", onChange, secretPhrase, key, }) {
    try {
        if (!fs_1.default.existsSync(filePath)) {
            console.warn(`⚠️  Env file not found at path: ${filePath}`);
        }
        const watcher = chokidar_1.default.watch(filePath, { persistent: true });
        watcher.on("change", (path) => {
            try {
                if (onChange) {
                    let watcherActive = state_1.sessionStore.getState().watcherActive;
                    if (watcherActive) {
                        const content = fs_1.default.readFileSync(path, "utf8"); // read file content
                        onChange(content, path);
                    }
                }
            }
            catch (err) {
                console.warn(`⚠️  Failed to read env file: ${err.message || err}`);
            }
        });
        watcher.on("error", (err) => {
            console.warn(`⚠️  Watcher error: ${err.message || err}`);
        });
        return watcher; // return watcher in case you want to close it later
    }
    catch (e) {
    }
}
// const readandsave
const config = async (
//   {
//   key:key__,
//   updateCloud=true,
//   // projectKey,
//   env = ".env",
//   branch = "main",
//   sync = false,
//   write = false,
//   watch = false,
//   onSync = () => {},
//    omit=[]
// }
conf) => {
    try {
        // let data =await  handleDecryptKeyPairLongData({encryptedString:key__,privateKey:PRIVATEKEY})
        // let {projectId:project,userKey:secretPhrase,userEmail:email,projectKey:keyy}=data
        //   // const [secretPhrase, email] = authPhrase.split("_kk_");
        //   sessionStore.getState().setSecretPhrase(secretPhrase);
        //   sessionStore.getState().setEmail(email);
        //   // const [keyy, project] = projectKey.split("_kk_");
        //   await loginWithPhrase(secretPhrase,email)
        //   let fetchproject = await getProjectById(project);
        //   sessionStore.getState().setProject(fetchproject.data);
        //   sessionStore
        //     .getState()
        //     .setConfig({ envfile: env, sync, onSync ,omit,updateCloud,write,branch});
        //     setinitalEnv()
        let { env, sync, onSync, omit, updateCloud, write, branch, project, secretPhrase, email, keyy, fetchproject, watch } = await (0, utils_1.initialize)(conf);
        let socket = new websocket_1.SocketClient({ project });
        if (fetchproject?.success) {
            socket.socket.emit("joinproject", { project: project });
        }
        else {
            console.warn("Invalid project");
            return;
        }
        await (0, utils_1.getEnvs)({ project: project, write });
        await (0, utils_1.mount)({
            path: env,
            secretPhrase,
            key: keyy,
            sync,
            project,
            fetchproject: fetchproject.data,
        });
        if (watch) {
            watchEnv({
                onChange: async (content) => {
                    await (0, utils_1.onChange)({
                        content,
                        secretPhrase,
                        key: keyy,
                        sync,
                        project,
                        fetchproject: fetchproject.data,
                    });
                },
                secretPhrase,
            });
        }
        let getEnvs_ = () => {
            let envs = state_1.envStore.getState().envs;
            return (0, utils_1.getenvObject)(envs);
        };
        if (conf.onLoad) {
            conf.onLoad({ envs: state_1.envStore.getState().envs });
        }
        return {
            getEnvs: getEnvs_
        };
    }
    catch (e) {
    }
};
exports.config = config;
let v = async () => {
    let key = "";
    (0, exports.config)({
        key,
        omit: ["key"],
        branch: "main",
        write: true,
        watch: true,
        updateCloud: true,
    });
};
// v()
//# sourceMappingURL=index.js.map