"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULTOMIT = exports.TerminalLoader = exports.initialize = exports.upgradeVersion = exports.updateProcessEnv = exports.getenvObject = exports.writeEnvFile = exports.getmetadata = exports.getchangeEnv = exports.loginWithPhrase = exports.ACTIONS = exports.getEnvs = exports.mergeEnvToFile = exports.addEnv = exports.onChange = exports.mount = exports.getProjectById = exports.parseAndUniqueEnv = exports.getreadabledate = void 0;
exports.parseEnvToList = parseEnvToList;
exports.cleanEnvString = cleanEnvString;
exports.listToEnvString = listToEnvString;
exports.httpRequest = httpRequest;
exports.getDeviceId = getDeviceId;
exports.getOrCreateConfig = getOrCreateConfig;
const moment_1 = __importDefault(require("moment"));
const lodash_1 = __importDefault(require("lodash"));
const cryption_1 = require("./cryption");
const getreadabledate = (date) => {
    return (0, moment_1.default)(date).fromNow();
};
exports.getreadabledate = getreadabledate;
function parseEnvToList(envContent) {
    return lodash_1.default.uniqBy(envContent
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line && !line.startsWith("#"))
        .map((line) => {
        const [key, ...rest] = line.split("=");
        let value = rest.join("=").trim();
        // Remove wrapping quotes if present
        if ((value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))) {
            value = value.slice(1, -1);
        }
        return { title: key.trim(), value };
    }), "title");
}
const parseAndUniqueEnv = (envContent) => {
    let v = state_1.envStore.getState().envs;
    let parseContent = parseEnvToList(envContent);
    return lodash_1.default.uniqBy(parseContent, "title");
};
exports.parseAndUniqueEnv = parseAndUniqueEnv;
function cleanEnvString(envContent) {
    return envContent
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line && !line.startsWith("#"))
        .map((line) => {
        const [key, ...rest] = line.split("=");
        let value = rest.join("=").trim();
        // Strip surrounding quotes if present
        if ((value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))) {
            value = value.slice(1, -1);
        }
        return `${key.trim()}=${value}`;
    })
        .join("\n");
}
function listToEnvString(list) {
    const raw = list.map((item) => `${item.title}=${item.value}`).join("\n");
    return cleanEnvString(raw);
}
const getProjectById = async ({ id, versioncontrol = true, task }) => {
    try {
        let secretPhrase = state_1.sessionStore.getState();
        if (!secretPhrase) {
            return;
        }
        let data = await httpRequest({ url: const_1.GETPROJECTBYIDURL + `?id=${id}` });
        if (data.success) {
            if (versioncontrol) {
                let d = await (0, exports.upgradeVersion)({ colab: data.data });
                if (d?.success) {
                    data = d;
                }
            }
        }
        else {
        }
        return data;
    }
    catch (e) {
        throw e;
    }
    finally {
    }
};
exports.getProjectById = getProjectById;
const mount = async ({ path, secretPhrase, key, sync, project, fetchproject, }) => {
    const content = fs_1.default.readFileSync(path, "utf8");
    await (0, exports.onChange)({ content, secretPhrase, key, sync, project, fetchproject });
};
exports.mount = mount;
const onChange = async ({ content, secretPhrase, key, sync, project, fetchproject, }) => {
    let c = (0, exports.parseAndUniqueEnv)(content);
    // await getEnvs({ project: project, key: fetchproject.data,write:false });
    await (0, exports.addEnv)({ secretPhrase, sync, body: c, project });
};
exports.onChange = onChange;
// let    addEnvHelper = async()=>{
// }
const addEnv = async ({ project, body, key, sync = false, secretPhrase, }) => {
    try {
        key = key || state_1.sessionStore.getState().project.colab.key;
        secretPhrase = secretPhrase || state_1.sessionStore.getState().secretPhrase;
        // console.log(key)
        await (0, exports.getEnvs)({ project: project, key: key, write: false });
        let branch = state_1.sessionStore.getState().config.branch || "main";
        let envs = state_1.envStore.getState().envs;
        if (!secretPhrase) {
            return;
        }
        let deHashedKey = (await (0, cryption_1.handleDecrypt)({
            encrypted: key,
            passphrase: secretPhrase,
        }));
        if (!deHashedKey) {
            return;
        }
        let omit = state_1.sessionStore.getState().config.omit || [];
        const loader = new TerminalLoader("encrypting envs", 50);
        const step = 50 / body.length;
        const hashedData_ = await Promise.all(body.map(async (item) => {
            loader.tick(step);
            const encryptedKey = (0, cryption_1.handleEncryptEnv)({
                data: item,
                passphrase: deHashedKey,
            });
            let v = envs.find((e) => e.title == item.title);
            return {
                ...encryptedKey,
                changed: (v?._id) ? (v?.value != item?.value) : (true),
                item: { ...item, ...(v?._id ? { _id: v?._id } : {}) },
                ...(v?._id ? { _id: v?._id } : {}),
            };
        }));
        const hashedData = hashedData_.filter((item) => !omit.includes(item.item.title));
        state_1.envStore
            .getState()
            .setEnvs(lodash_1.default.uniqBy([
            ...hashedData_.filter((e) => e.item).map((e) => ({ ...e.item, dItem: e.item, eItem: e })),
            ...(envs || []),
        ], "title"));
        let config = state_1.sessionStore.getState().config;
        if (!config.updateCloud) {
            return;
        }
        let httpdata = hashedData.filter((e) => e.changed).map((e) => lodash_1.default.omit(e, ["item"]));
        let data = httpdata.length > 0 ? await httpRequest({
            url: (sync ? const_1.UPDATEENVURL : const_1.ADDENVURL) + `?id=${project}`,
            method: "PUT",
            body: { data: httpdata, branch },
        }) : {};
        if (data?.success) {
            let v = data?.data || [];
            const decripted = await Promise.all(v.map(async (item) => {
                let c = (0, cryption_1.handleDecryptEnv)(item, deHashedKey);
                return { ...item, ...c, dItem: c, eItem: item };
            }));
            let envs_ = state_1.envStore.getState().envs;
            state_1.envStore
                .getState()
                .setEnvs(lodash_1.default.uniqBy([...decripted, ...(envs_ || [])], "title"));
            return {
                data: hashedData.map((e) => {
                    let c = v.find((ee) => ee.title == e.title);
                    if (c) {
                        return { ...c, ...e.item };
                    }
                    return e;
                }),
            };
        }
        else {
        }
    }
    catch (e) {
        throw e;
    }
    finally {
    }
};
exports.addEnv = addEnv;
const mergeEnvToFile = (envdata) => {
    let projectId = state_1.sessionStore.getState().projectId;
    let envs = state_1.envStore.getState().envs;
    let omit = state_1.sessionStore.getState().config.omit;
    let v = [];
    if (projectId == process.env.envProjectId) {
        v = lodash_1.default.uniqBy([...envdata, ...(envs || [])], "title");
    }
    else {
        v = lodash_1.default.uniqBy([...envdata, ...(envs || []).filter((e) => {
                return omit.includes(e.title);
            })], "title");
    }
    return v;
};
exports.mergeEnvToFile = mergeEnvToFile;
const getEnvs = async ({ project, key, write = true, }) => {
    key = key || state_1.sessionStore.getState().project.colab.key;
    let branch = state_1.sessionStore.getState().config.branch || "main";
    const secretPhrase = state_1.sessionStore.getState().secretPhrase;
    const config = state_1.sessionStore.getState().config;
    try {
        if (!secretPhrase) {
            return;
        }
        let deHashedKey = (await (0, cryption_1.handleDecrypt)({
            encrypted: key,
            passphrase: secretPhrase,
        }));
        if (!deHashedKey) {
            return;
        }
        let data = await httpRequest({ url: const_1.FETCHENVURL + `?id=${project}&branch=${branch || "main"}` });
        const omit = state_1.sessionStore.getState().config.omit || [];
        if (data.success) {
            const loader = new TerminalLoader("Decrypting env", 50);
            const step = 50 / data.data.length;
            let envs_ = state_1.envStore.getState().envs;
            const decripted_ = await Promise.all(data.data.map(async (item) => {
                let c = (0, cryption_1.handleDecryptEnv)(item, deHashedKey);
                // console.log("dddddddddd",step)
                loader.tick(step);
                const existing = envs_.find((e) => e.title === c.title);
                let obj = { ...item, ...c, dItem: c, eItem: item };
                if (existing) {
                    obj.pItem = existing;
                }
                return obj;
            }));
            const decripted = decripted_.filter((item) => !omit.includes(item.title));
            let envs = state_1.envStore.getState().envs;
            let v = (0, exports.mergeEnvToFile)(decripted);
            (0, exports.updateProcessEnv)(decripted);
            if (write) {
                await (0, exports.writeEnvFile)(v, config.envfile);
            }
            // envStore.getState().setEnvs(decripted);
            state_1.envStore.getState().setEnvs(v);
            return { decripted };
        }
        else {
            return null;
        }
    }
    catch (e) {
        console.log(e);
    }
    finally {
    }
};
exports.getEnvs = getEnvs;
const axios_1 = __importDefault(require("axios"));
const state_1 = require("./state");
const const_1 = require("./const");
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
// export getsignedkey()=>{
// }
var ACTIONS;
(function (ACTIONS) {
    ACTIONS["KILL"] = "KILL";
})(ACTIONS || (exports.ACTIONS = ACTIONS = {}));
const loginWithPhrase = async ({ phrase, task, colabId }) => {
    try {
        let logginin = state_1.sessionStore.getState().logginin;
        if (logginin) {
            await sleep(5000);
            return await (0, exports.loginWithPhrase)({ phrase, colabId });
        }
        let authKey = state_1.sessionStore.getState().authKey;
        let token = state_1.sessionStore.getState().token;
        if (authKey && token) {
            return;
        }
        state_1.sessionStore.getState().setLogginIn(true);
        let keydata = await httpRequest({ url: const_1.GETSIGNEDKEYURL, login: false, method: "POST",
            body: { colabId }, });
        let decryptedkeydata;
        if (keydata.success) {
            if (task == "clone") {
                if (process.env.envVersion == keydata.data.colab.project.envVersion && process.env.envProjectId == keydata.data.colab.project._id) {
                    return { action: ACTIONS.KILL, message: "everything up to date" };
                }
            }
            //   let secretKey  =  await handleDecrypt({encrypted:{...keydata?.data?.user,encrypted:keydata?.data?.user?.privateKey},passphrase:phrase})
            //  decryptedkeydata = await decryptMessageFromKeyPair({encrypted:keydata?.data.signedData,privateKey:secretKey})
            let secretKey = await (0, cryption_1.handleDecrypt)({ encrypted: keydata.data.colab.privateKey, passphrase: phrase });
            decryptedkeydata = await (0, cryption_1.decryptMessageFromKeyPair)({ encrypted: keydata?.data.signedData, privateKey: secretKey });
        }
        else {
            await sleep(3000);
            return await (0, exports.loginWithPhrase)({ phrase, colabId });
            // toast.error(keydata?.message||"An error occured")
        }
        let req = await httpRequest({
            url: const_1.LOGINWITHPHRASE,
            login: false,
            method: "POST",
            body: { secret: decryptedkeydata?.decrypted, colabId },
        });
        if (req.success) {
            state_1.sessionStore.getState().setLogginIn(false);
            state_1.sessionStore.getState().login(req.data.user, req.data.token, req.data.authKey);
            setTimeout(() => {
                state_1.sessionStore.getState().setAuthKey(null);
                // loginWithPhrase(phrase, email);
            }, 1000 * 50);
            let savedProject = state_1.sessionStore.getState().project;
            if (savedProject) {
                (0, exports.upgradeVersion)({ force: true });
            }
        }
        else {
            console.warn("Login failed, retrying in 3s...");
            await sleep(3000);
            return await (0, exports.loginWithPhrase)({ phrase, colabId });
        }
    }
    catch (e) {
        console.error("Error in loginWithPhrase:", e);
        console.warn("Retrying in 3s...");
        await sleep(3000);
        return await (0, exports.loginWithPhrase)({ phrase, colabId });
    }
};
exports.loginWithPhrase = loginWithPhrase;
// General HTTP function
// your re-login fn
async function httpRequest(data_) {
    let { url, method = "GET", login = true, params, body, headers = {} } = data_;
    // üîë Get token from session
    let token = state_1.sessionStore.getState().token;
    let authKey = state_1.sessionStore.getState().authKey;
    // If login required but no token ‚Üí try re-login
    if ((!token || !authKey) && login) {
        const phrase = state_1.sessionStore.getState().secretPhrase;
        const email = state_1.sessionStore.getState().email;
        const colabId = state_1.sessionStore.getState().colabId;
        if (phrase) {
            let data = await (0, exports.loginWithPhrase)({ phrase, colabId });
            token = state_1.sessionStore.getState().token; // refresh token after login
        }
        if (!token) {
            throw new Error("Unauthorized: No token available");
        }
    }
    // Merge Authorization header
    const authHeaders = (token && authKey)
        ? { Authorization: `Bearer ${((token || "") + "123456789" + (authKey || "")) || ""}` }
        // ? { Authorization: `Bearer ${token} `, ...headers }
        : headers;
    // ---- Axios request ----
    const config = {
        url,
        method: method,
        headers: { ...authHeaders, "x-device-id": getDeviceId(), "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36", },
        params, // Axios handles params automatically
        data: body,
    };
    try {
        const response = await axios_1.default.request(config);
        return response.data;
    }
    catch (e) {
        console.error(e?.response?.data?.message || e?.message || "An error occured");
        // throw(e)
        return e?.response?.data || { success: false };
        // process.kill(0)
    }
}
const getchangeEnv = async (updatedenvs = []) => {
    const secretPhrase = state_1.sessionStore.getState().secretPhrase;
    const project = state_1.sessionStore.getState().project;
    const envs = state_1.envStore.getState().envs;
    const omit = state_1.sessionStore.getState().config.omit || [];
    try {
        if (!secretPhrase) {
            return;
        }
        let deHashedKey = (await (0, cryption_1.handleDecrypt)({
            encrypted: project.colab.key,
            passphrase: secretPhrase,
        }));
        if (!deHashedKey) {
            return;
        }
        const decriptedenvs_ = await Promise.all(updatedenvs.map(async (item) => {
            let c = (0, cryption_1.handleDecryptEnv)(item, deHashedKey);
            const existing = envs.find((e) => e.title === c.title || (e?._id && e?._id == item?._id));
            let obj = { ...item, ...c, dItem: c, eItem: item };
            if (existing) {
                obj.pItem = existing;
            }
            return obj;
        }));
        const decriptedenvs = decriptedenvs_.filter((item) => !omit.includes(item.title));
        let v = decriptedenvs.reduce((acc, env) => {
            const existing = envs.find((e) => e.title === env.title || (e?._id && e?._id == env?._id));
            if (!existing || existing.value !== env.value || existing.title != env.title) {
                acc.changes.push(env);
            }
            // let v = 
            return acc;
        }, {
            list: lodash_1.default.uniqBy(lodash_1.default.uniqBy((0, exports.mergeEnvToFile)(decriptedenvs), "title"), "_id"),
            changes: [],
        });
        state_1.envStore.getState().setEnvs(v.list);
        return v;
    }
    catch (e) { }
};
exports.getchangeEnv = getchangeEnv;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
/**
 * Write env objects to .env file
 * @param envs array of {title, value}
 * @param filePath optional path to env file
 */
// function customEnvUnique(c = [], envs = []) {
//   const seen = new Set();
//   const merged = [];
//   const getKey = (item) => {
//     if (item?._id != null && item._id !== "") return item._id;
//     if (item?.ditem?.title != null && item.ditem.title !== "") return item.ditem.title;
//     if (item?.title != null && item.title !== "") return item.title;
//     return null;
//   };
//   for (const item of [...c, ...envs]) {
//     const key = getKey(item);
//     if (!key || seen.has(key)) continue;
//     seen.add(key);
//     merged.push(item);
//   }
//   return merged;
// }
function customEnvUnique(c = [], envs = []) {
    const merged = [];
    const seenIds = new Set();
    const seenDitemTitles = new Set();
    const seenTitles = new Set();
    for (const item of [...c, ...envs]) {
        const id = item?._id;
        const ditemTitle = item?.pItem?.dItem?.title;
        const citemTitle = item?.dItem?.title;
        const title = item?.title;
        const alreadyExists = (id && seenIds.has(id)) ||
            (ditemTitle && seenDitemTitles.has(ditemTitle)) ||
            (title && seenTitles.has(title));
        if (alreadyExists)
            continue;
        if (id)
            seenIds.add(id);
        if (ditemTitle)
            seenDitemTitles.add(ditemTitle);
        if (title)
            seenTitles.add(title);
        merged.push(item);
    }
    return merged;
}
const getmetadata = () => {
    let project = state_1.sessionStore.getState().project;
    let proj = project.colab.project;
    let metadata = [
        { title: "envVersion", value: proj.envVersion },
        { title: "envName", value: proj.name },
        { title: "envDescription", value: proj.description },
        { title: "envProjectId", value: proj._id },
    ];
    return metadata;
};
exports.getmetadata = getmetadata;
const writeEnvFile = async (envs, filePath = path_1.default.resolve(process.cwd(), ".env")) => {
    try {
        state_1.sessionStore.getState().setWatcherActive(false);
        let write = state_1.sessionStore.getState().config.write;
        // console.log(envs,write)
        if (!write) {
            return;
        }
        // Convert env objects to "KEY=VALUE" lines
        if (!fs_1.default.existsSync(filePath)) {
            console.warn(`‚ö†Ô∏è  Env file not found at path: ${filePath}`);
        }
        let c = [];
        // try{
        //   const content_ = fs.readFileSync(filePath, "utf8");
        //      c = parseAndUniqueEnv(content_);
        // }catch(e){
        // }
        // let lines_ = _.uniqBy([...envs,...c],  (item) =>  item?._id)
        // let lines_ = customEnvUnique(envs,c)
        let lines = lodash_1.default.uniqBy([...(0, exports.getmetadata)(), ...envs, ...c], (item) => item?.dItem?.title || item?.title).map((env) => `${env.title}="${env.value}"`);
        // lines = _.uniqBy([...lines, ...c.map((e) => `${e.title}=${e.value}`)], (line) => line.split("=")[0]);
        // Join lines with newlines
        const content = lines.join("\n");
        // Write to file
        await fs_1.default.promises.writeFile(filePath, content, { encoding: "utf8" });
        return { success: true };
    }
    catch (err) {
        console.error("Error writing .env file:", err);
        return { success: false, error: err.message || String(err) };
    }
    finally {
        state_1.sessionStore.getState().setWatcherActive(true);
    }
};
exports.writeEnvFile = writeEnvFile;
const getenvObject = (envList) => {
    return envList.reduce((acc, env) => {
        acc[env.title] = env.value;
        return acc;
    }, {});
};
exports.getenvObject = getenvObject;
const updateProcessEnv = (envList) => {
    if (!Array.isArray(envList))
        return;
    [...(0, exports.getmetadata)(), ...envList].forEach(({ title, value }) => {
        if (title) {
            process.env[title] = value;
        }
    });
};
exports.updateProcessEnv = updateProcessEnv;
const upgradeVersion = async ({ colab, secretPhrase, force = false }) => {
    try {
        let savedProject = state_1.sessionStore.getState().project;
        secretPhrase = secretPhrase || state_1.sessionStore.getState().secretPhrase;
        //  console.log("upvers",force,colab.colab.keyVersion != colab.project.keyVersion,colab.colab.keyVersion , colab.project.keyVersion)
        //  console.log(colab)
        if (force) {
            let proj = await (0, exports.getProjectById)({ id: (colab || savedProject).project._id, versioncontrol: false });
            colab = proj.data;
        }
        // console.log(colab?.colab)
        if (colab.colab.keyVersion != colab.project.keyVersion) {
            // let key = colab.key
            let privateKey = await (0, cryption_1.handleDecrypt)({ encrypted: colab.colab.privateKey, passphrase: secretPhrase });
            let decryptedKey = await (0, cryption_1.decryptMessageFromKeyPair)({ encrypted: colab.colab.key, privateKey: privateKey });
            let version = colab.project.keyVersion;
            let encryptedKey = await (0, cryption_1.handleEncrypt)({
                data: decryptedKey.decrypted,
                passphrase: secretPhrase,
                stringify: true
            });
            // console.log(encryptedKey,"encryptedKey")
            let project = await httpRequest({
                url: const_1.UPGRADEVERSIONURL,
                body: { version, hashedkey: encryptedKey, id: colab.project._id },
                method: "POST"
            });
            //  let project =    await getProjectById(colab.project._id)
            if (project.success) {
                state_1.sessionStore.getState().setProject(project.data);
                // await getEnvs({project:colab.project._id,write:true})
            }
            return project;
        }
    }
    catch (e) {
        console.log(e);
    }
};
exports.upgradeVersion = upgradeVersion;
const initialize = async (data_) => {
    let { key: key__, updateCloud = true, task, 
    // projectKey,
    env = ".env", branch, sync = false, write = false, watch = false, onSync = () => { }, omit = [] } = data_;
    branch = branch || getCurrentBranch();
    let data = await (0, cryption_1.handleDecryptKeyPairLongData)({ encryptedString: key__, privateKey: const_1.PRIVATEKEY });
    let { projectId: project, userKey: secretPhrase, userEmail: email, projectKey: keyy, colabId } = data;
    // const [secretPhrase, email] = authPhrase.split("_kk_");
    state_1.sessionStore.getState().setSecretPhrase(secretPhrase);
    state_1.sessionStore.getState().setEmail(email);
    state_1.sessionStore.getState().setProjectId(project);
    state_1.sessionStore.getState().setColabId(colabId);
    // const [keyy, project] = projectKey.split("_kk_");
    // console.log("ddd",data)
    let logindata = await (0, exports.loginWithPhrase)({ phrase: secretPhrase, colabId, task });
    if (logindata?.action) {
        let action = logindata.action;
        switch (action) {
            case ACTIONS.KILL: {
                console.log(logindata?.message || "process killed");
                return logindata;
            }
        }
    }
    // console.log("ddddd")
    let fetchproject = await (0, exports.getProjectById)({ id: project, task });
    if (fetchproject.success) {
        // console.log(fetchproject.data)
    }
    state_1.sessionStore.getState().setProject(fetchproject.data);
    state_1.sessionStore
        .getState()
        .setConfig({ envfile: env, sync, onSync, omit: [...omit, ...exports.DEFAULTOMIT], updateCloud, write, branch, projectKey: keyy });
    setinitalEnv(key__);
    return { env, sync, onSync, omit, updateCloud, write, branch, project, secretPhrase, email, keyy, fetchproject, watch };
};
exports.initialize = initialize;
const readenv = () => {
    let path = state_1.sessionStore.getState().config.envfile;
    const content = fs_1.default.readFileSync(path, "utf8");
    let c = (0, exports.parseAndUniqueEnv)(content);
    return c;
};
const setinitalEnv = (key) => {
    try {
        let c = readenv();
        let omit = state_1.sessionStore.getState().config.omit || [];
        for (let val of c) {
            if (val.value == key) {
                omit.push(val.title);
            }
        }
        state_1.sessionStore.getState().config.omit = omit;
        state_1.envStore.getState().setEnvs(c);
    }
    catch (e) {
    }
};
const child_process_1 = require("child_process");
function getCurrentBranch() {
    try {
        const branch = (0, child_process_1.execSync)('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();
        return branch || 'main'; // fallback if output is empty
    }
    catch {
        return 'main'; // fallback if git fails or not a repo
    }
}
const DEVICE_ID_FILE = path_1.default.join(process.cwd(), ".device-id"); // hidden file in project root
function getDeviceId() {
    // --- Browser ---
    // if (typeof window !== "undefined" && window.localStorage) {
    //   let deviceId = localStorage.getItem("x-device-id");
    //   if (!deviceId) {
    //     deviceId = crypto.randomUUID(); // generate UUID
    //     localStorage.setItem("x-device-id", deviceId);
    //   }
    //   return deviceId;
    // }
    // --- Node.js ---
    if (typeof process !== "undefined") {
        if (fs_1.default.existsSync(DEVICE_ID_FILE)) {
            return fs_1.default.readFileSync(DEVICE_ID_FILE, "utf-8");
        }
        else {
            const deviceId = crypto.randomUUID();
            fs_1.default.writeFileSync(DEVICE_ID_FILE, deviceId, { encoding: "utf-8", flag: "w" });
            return deviceId;
        }
    }
    throw new Error("Cannot generate device ID in this environment");
}
const readline_1 = __importDefault(require("readline"));
class TerminalLoader {
    total;
    current;
    spinnerChars;
    spinnerIndex;
    startTime;
    loadText;
    constructor(loadText, total) {
        this.total = total;
        this.current = 0;
        this.spinnerChars = ["|", "/", "-", "\\"];
        this.spinnerIndex = 0;
        this.startTime = Date.now();
        this.loadText = loadText;
    }
    /**
     * Advance progress by a step (can be decimal) or move to a specific point.
     * @param step - Amount to increment (optional if specifying `point`)
     * @param message - Optional message override
     * @param point - Optional specific position to move to (0..total)
     */
    tick(step, message, point) {
        if (point !== undefined) {
            this.current = Math.min(point, this.total);
        }
        else if (step !== undefined) {
            this.current = Math.min(this.current + step, this.total);
        }
        this.spinnerIndex++;
        const percentage = Math.floor((this.current * 100) / this.total);
        const filledLength = Math.floor((this.current / this.total) * 50); // bar size
        const filled = "=".repeat(filledLength);
        const empty = " ".repeat(50 - filledLength);
        const elapsed = (Date.now() - this.startTime) / 1000;
        const statusMsg = message || this.loadText;
        readline_1.default.clearLine(process.stdout, 0);
        readline_1.default.cursorTo(process.stdout, 0);
        process.stdout.write(`${statusMsg} ${this.spinnerChars[this.spinnerIndex % this.spinnerChars.length]} [${filled}>${empty}] ${percentage}% | ‚è± ${elapsed.toFixed(1)}s`);
        if (this.current >= this.total) {
            console.log(`\n‚úÖ Done in ${elapsed.toFixed(1)}s!`);
            return true;
        }
        return false;
    }
    /** Restart loader from beginning (for reuse) */
    reset(loadText) {
        this.current = 0;
        this.spinnerIndex = 0;
        this.startTime = Date.now();
        this.loadText = loadText;
    }
}
exports.TerminalLoader = TerminalLoader;
const os_1 = __importDefault(require("os"));
exports.DEFAULTOMIT = ["envVersion", "envName", "envDescription", "envProjectId"];
function getOrCreateConfig(updates = {}) {
    const configDir = path_1.default.join(os_1.default.homedir(), ".config", "myapp");
    const configPath = path_1.default.join(configDir, "config.json");
    // Ensure directory exists
    if (!fs_1.default.existsSync(configDir)) {
        fs_1.default.mkdirSync(configDir, { recursive: true });
    }
    let configData = {};
    // Read existing file if present
    if (fs_1.default.existsSync(configPath)) {
        try {
            const fileContent = fs_1.default.readFileSync(configPath, "utf-8");
            configData = JSON.parse(fileContent);
        }
        catch (err) {
            console.warn("‚ö†Ô∏è Invalid JSON in config file, resetting...");
            configData = {};
        }
    }
    else {
        configData = { envVersion: 1 };
    }
    // Merge updates without overwriting existing keys
    const newConfig = { ...configData, ...updates };
    // Write back only if changed
    fs_1.default.writeFileSync(configPath, JSON.stringify(newConfig, null, 2), "utf-8");
    return newConfig;
}
//# sourceMappingURL=utils.js.map