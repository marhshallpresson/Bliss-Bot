"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketClient = void 0;
const socket_io_client_1 = require("socket.io-client");
const state_1 = require("./state");
const utils_1 = require("./utils");
const SERVER_URL = "http://172.20.10.2:5002";
class SocketClient {
    socket;
    constructor() {
        // Initialize the socket inside the constructor
        this.socket = (0, socket_io_client_1.io)(SERVER_URL, {
            reconnection: true,
            transports: ["websocket"], // force websocket
            auth: { token: state_1.sessionStore.getState().token }, // make sure token exists
        });
        this.registerEvents();
    }
    registerEvents() {
        this.socket.on("connect", () => {
            console.log("Connected to server:", this.socket.id);
            this.socket.emit("message", "Hello from Node.js client!");
        });
        this.socket.on("connect_error", (err) => {
            console.error("Connection error:", err.message);
        });
        this.socket.on("connect_timeout", () => {
            console.error("Connection timed out");
        });
        this.socket.on("envupdated", async (msg) => {
            setTimeout(async () => {
                console.log("envupdated:");
                let config = state_1.sessionStore.getState().config;
                let envs = await (0, utils_1.getchangeEnv)(JSON.parse(msg));
                if (config.onSync) {
                    config.onSync({ list: envs.list, changes: (0, utils_1.getenvObject)(envs.changes) });
                }
                (0, utils_1.updateProcessEnv)(envs.changes);
                if (envs.changes.length > 0) {
                    await (0, utils_1.writeEnvFile)(envs.list, config.envfile);
                }
            }, 5000);
        });
        this.socket.on("disconnect", () => {
            console.log("Disconnected from server");
        });
    }
}
exports.SocketClient = SocketClient;
//# sourceMappingURL=websocket.js.map