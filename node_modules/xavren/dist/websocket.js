"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketClient = void 0;
const socket_io_client_1 = require("socket.io-client");
const state_1 = require("./state");
const utils_1 = require("./utils");
const const_1 = require("./const");
const SERVER_URL = const_1.DOMAIN;
class SocketClient {
    socket;
    project;
    constructor({ project }) {
        this.project = project;
        // Initialize the socket inside the constructor
        this.socket = (0, socket_io_client_1.io)(SERVER_URL, {
            reconnection: true,
            transports: ["websocket"], // force websocket
            auth: { token: state_1.sessionStore.getState().token, authKey: state_1.sessionStore.getState().authKey }, // make sure token exists
        });
        this.registerEvents();
    }
    registerEvents() {
        this.socket.on("connect", () => {
            console.log("Connected to server:", this.socket.id);
            this.socket.emit("message", "Hello from Node.js client!");
            this.socket.emit("joinproject", { project: this.project });
        });
        this.socket.on("reconnect", () => {
            console.log("reonnected to server:", this.socket.id);
            // this.socket.emit("message", "Hello from Node.js client!");
            this.socket.emit("joinproject", { project: this.project });
        });
        this.socket.on("disconnect", async () => {
            console.log("Disconnected from server");
            let { token, authKey, secretPhrase, colabId } = state_1.sessionStore.getState();
            if (!token || !authKey) {
                console.log("⚠️ Token missing during reconnect, trying login...");
                try {
                    await (0, utils_1.loginWithPhrase)({ phrase: secretPhrase, colabId });
                    // loginWithPhrase updates sessionStore directly
                    // pull new values from store
                    const { token: newToken, authKey: newAuthKey } = state_1.sessionStore.getState();
                    this.socket.io.opts.auth = {
                        token: newToken,
                        authKey: newAuthKey,
                    };
                    console.log("✅ Refreshed session during reconnect");
                }
                catch (err) {
                    console.error("❌ Failed to refresh session", err);
                    this.socket.disconnect();
                    // In Node.js, no window.location
                    process.exit(1); // or handle differently (e.g., retry logic)
                }
            }
            else {
                // token exists, just update auth for safety
                this.socket.io.opts.auth = { token, authKey };
            }
        });
        this.socket.on("connect_error", (err) => {
            console.error("Connection error:", err.message);
        });
        this.socket.on("connect_timeout", () => {
            console.error("Connection timed out");
        });
        // lll=kks
        // sss=princejoy
        // fj=k
        // kk=knnnnn
        // sssssssssssssssss=ssssssssccccccccccccvvbbbbbb
        // asdfgfdawerdf=sdfgdsregf
        this.socket.on("envupdated", async (msg) => {
            setTimeout(async () => {
                (0, utils_1.upgradeVersion)({ force: true });
                console.log("envupdated:");
                let config = state_1.sessionStore.getState().config;
                let envs = await (0, utils_1.getchangeEnv)(JSON.parse(msg));
                if (config.onSync) {
                    config.onSync({ list: envs.list, changes: (0, utils_1.getenvObject)(envs.changes) });
                }
                (0, utils_1.updateProcessEnv)(envs.changes);
                if (envs.changes.length > 0) {
                    await (0, utils_1.writeEnvFile)(envs.list, config.envfile);
                }
            }, 5000);
        });
        // this.socket.on("disconnect", () => {
        //   console.log("Disconnected from server");
        // });
    }
}
exports.SocketClient = SocketClient;
//# sourceMappingURL=websocket.js.map