"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProcessEnv = exports.getenvObject = exports.writeEnvFile = exports.getchangeEnv = exports.loginWithPhrase = exports.getEnvs = exports.addEnv = exports.getProjectById = exports.parseAndUniqueEnv = exports.getreadabledate = void 0;
exports.parseEnvToList = parseEnvToList;
exports.cleanEnvString = cleanEnvString;
exports.listToEnvString = listToEnvString;
exports.httpRequest = httpRequest;
const moment_1 = __importDefault(require("moment"));
const lodash_1 = __importDefault(require("lodash"));
const cryption_1 = require("./cryption");
const getreadabledate = (date) => {
    return (0, moment_1.default)(date).fromNow();
};
exports.getreadabledate = getreadabledate;
function parseEnvToList(envContent) {
    return lodash_1.default.uniqBy(envContent
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line && !line.startsWith("#"))
        .map((line) => {
        const [key, ...rest] = line.split("=");
        let value = rest.join("=").trim();
        // Remove wrapping quotes if present
        if ((value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))) {
            value = value.slice(1, -1);
        }
        return { title: key.trim(), value };
    }), "title");
}
const parseAndUniqueEnv = (envContent) => {
    let v = state_1.envStore.getState().envs;
    let parseContent = parseEnvToList(envContent);
    return lodash_1.default.uniqBy(parseContent, "title");
};
exports.parseAndUniqueEnv = parseAndUniqueEnv;
function cleanEnvString(envContent) {
    return envContent
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line && !line.startsWith("#"))
        .map((line) => {
        const [key, ...rest] = line.split("=");
        let value = rest.join("=").trim();
        // Strip surrounding quotes if present
        if ((value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))) {
            value = value.slice(1, -1);
        }
        return `${key.trim()}=${value}`;
    })
        .join("\n");
}
function listToEnvString(list) {
    const raw = list.map((item) => `${item.title}=${item.value}`).join("\n");
    return cleanEnvString(raw);
}
const getProjectById = async (id) => {
    try {
        let secretPhrase = state_1.sessionStore.getState();
        if (!secretPhrase) {
            return;
        }
        let data = await httpRequest({ url: const_1.GETPROJECTBYIDURL + `?id=${id}` });
        if (data.success) {
        }
        else {
        }
        return data;
    }
    catch (e) {
        throw e;
    }
    finally {
    }
};
exports.getProjectById = getProjectById;
const addEnv = async ({ project, body, key, sync = false, secretPhrase, }) => {
    try {
        let envs = state_1.envStore.getState().envs;
        if (!secretPhrase) {
            return;
        }
        let deHashedKey = (await (0, cryption_1.handleDecrypt)({
            encrypted: key,
            passphrase: secretPhrase,
        }));
        if (!deHashedKey) {
            return;
        }
        let omit = state_1.sessionStore.getState().config.omit || [];
        const hashedData_ = await Promise.all(body.map(async (item) => {
            const encryptedKey = (0, cryption_1.handleEncryptEnv)({
                data: item,
                passphrase: deHashedKey,
            });
            let v = envs.find((e) => e.title == item.title);
            return {
                ...encryptedKey,
                item: { ...item, ...(v?._id ? { _id: v?._id } : {}) },
                ...(v?._id ? { _id: v?._id } : {}),
            };
        }));
        const hashedData = hashedData_.filter((item) => !omit.includes(item.item.title));
        state_1.envStore
            .getState()
            .setEnvs(lodash_1.default.uniqBy([
            ...hashedData.filter((e) => e.item).map((e) => e.item),
            ...(envs || []),
        ], "title"));
        let config = state_1.sessionStore.getState().config;
        if (!config.updateCloud) {
            return;
        }
        let data = await httpRequest({
            url: (sync ? const_1.UPDATEENVURL : const_1.ADDENVURL) + `?id=${project}`,
            method: "PUT",
            body: hashedData.map((e) => lodash_1.default.omit(e, ["item"])),
        });
        if (data.success) {
            let v = data?.data || [];
            const decripted = await Promise.all(v.map(async (item) => {
                let c = (0, cryption_1.handleDecryptEnv)(item, deHashedKey);
                return { ...item, ...c };
            }));
            state_1.envStore
                .getState()
                .setEnvs(lodash_1.default.uniqBy([...decripted, ...(envs || [])], "title"));
            return {
                data: hashedData.map((e) => {
                    let c = v.find((ee) => ee.title == e.title);
                    if (c) {
                        return { ...c, ...e.item };
                    }
                    return e;
                }),
            };
        }
        else {
        }
    }
    catch (e) {
        throw e;
    }
    finally {
    }
};
exports.addEnv = addEnv;
const getEnvs = async ({ project, key, }) => {
    const secretPhrase = state_1.sessionStore.getState().secretPhrase;
    const config = state_1.sessionStore.getState().config;
    try {
        if (!secretPhrase) {
            return;
        }
        let deHashedKey = (await (0, cryption_1.handleDecrypt)({
            encrypted: key,
            passphrase: secretPhrase,
        }));
        if (!deHashedKey) {
            return;
        }
        let data = await httpRequest({ url: const_1.FETCHENVURL + `?id=${project}` });
        if (data.success) {
            const decripted = await Promise.all(data.data.map(async (item) => {
                let c = (0, cryption_1.handleDecryptEnv)(item, deHashedKey);
                return { ...item, ...c };
            }));
            (0, exports.updateProcessEnv)(decripted);
            let envs = state_1.envStore.getState().envs;
            await (0, exports.writeEnvFile)(lodash_1.default.uniqBy([...decripted, ...(envs || [])], "title"), config.envfile);
            state_1.envStore.getState().setEnvs(decripted);
            return { decripted };
        }
        else {
            return null;
        }
    }
    catch (e) {
    }
    finally {
    }
};
exports.getEnvs = getEnvs;
const axios_1 = __importDefault(require("axios"));
const state_1 = require("./state");
const const_1 = require("./const");
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const loginWithPhrase = async (phrase, email) => {
    try {
        let req = await httpRequest({
            url: const_1.LOGINWITHPHRASE,
            login: false,
            method: "POST",
            body: { secret: phrase, email },
        });
        if (req.success) {
            state_1.sessionStore.getState().login(req.data.user, req.data.token);
        }
        else {
            console.warn("Login failed, retrying in 3s...");
            await sleep(3000);
            await (0, exports.loginWithPhrase)(phrase, email);
        }
    }
    catch (e) {
        console.error("Error in loginWithPhrase:", e);
        console.warn("Retrying in 3s...");
        await sleep(3000);
        await (0, exports.loginWithPhrase)(phrase, email);
    }
};
exports.loginWithPhrase = loginWithPhrase;
// General HTTP function
// your re-login fn
async function httpRequest(data_) {
    let { url, method = "GET", login = true, params, body, headers = {} } = data_;
    // ðŸ”‘ Get token from session
    let token = state_1.sessionStore.getState().token;
    // If login required but no token â†’ try re-login
    if (!token && login) {
        const phrase = state_1.sessionStore.getState().secretPhrase;
        const email = state_1.sessionStore.getState().email;
        if (phrase) {
            let data = await (0, exports.loginWithPhrase)(phrase, email);
            token = state_1.sessionStore.getState().token; // refresh token after login
        }
        if (!token) {
            throw new Error("Unauthorized: No token available");
        }
    }
    // Merge Authorization header
    const authHeaders = token
        ? { Authorization: `Bearer ${token}`, ...headers }
        : headers;
    // ---- Axios request ----
    const config = {
        url,
        method: method,
        headers: authHeaders,
        params, // Axios handles params automatically
        data: body,
    };
    try {
        const response = await axios_1.default.request(config);
        return response.data;
    }
    catch (e) {
        console.log(e);
        console.error(e?.response?.data?.message || e?.message || "An error occured");
        // throw(e)
        return e?.response?.data || { success: false };
        // process.kill(0)
    }
}
const getchangeEnv = async (updatedenvs = []) => {
    const secretPhrase = state_1.sessionStore.getState().secretPhrase;
    const project = state_1.sessionStore.getState().project;
    const envs = state_1.envStore.getState().envs;
    try {
        if (!secretPhrase) {
            return;
        }
        let deHashedKey = (await (0, cryption_1.handleDecrypt)({
            encrypted: project,
            passphrase: secretPhrase,
        }));
        if (!deHashedKey) {
            return;
        }
        const decriptedenvs = await Promise.all(updatedenvs.map(async (item) => {
            let c = (0, cryption_1.handleDecryptEnv)(item, deHashedKey);
            return { ...item, ...c };
        }));
        let v = decriptedenvs.reduce((acc, env) => {
            const existing = envs.find((e) => e.title === env.title);
            if (!existing || existing.value !== env.value) {
                acc.changes.push(env);
            }
            return acc;
        }, {
            list: lodash_1.default.uniqBy(lodash_1.default.uniqBy([...decriptedenvs, ...envs], "title"), "_id"),
            changes: [],
        });
        state_1.envStore.getState().setEnvs(v.list);
        return v;
    }
    catch (e) { }
};
exports.getchangeEnv = getchangeEnv;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
/**
 * Write env objects to .env file
 * @param envs array of {title, value}
 * @param filePath optional path to env file
 */
const writeEnvFile = async (envs, filePath = path_1.default.resolve(process.cwd(), ".env")) => {
    try {
        // Convert env objects to "KEY=VALUE" lines
        if (!fs_1.default.existsSync(filePath)) {
            console.warn(`âš ï¸  Env file not found at path: ${filePath}`);
        }
        const lines = envs.map((env) => `${env.title}=${env.value}`);
        // Join lines with newlines
        const content = lines.join("\n");
        // Write to file
        await fs_1.default.promises.writeFile(filePath, content, { encoding: "utf8" });
        return { success: true };
    }
    catch (err) {
        console.error("Error writing .env file:", err);
        return { success: false, error: err.message || String(err) };
    }
};
exports.writeEnvFile = writeEnvFile;
const getenvObject = (envList) => {
    return envList.reduce((acc, env) => {
        acc[env.title] = env.value;
        return acc;
    }, {});
};
exports.getenvObject = getenvObject;
const updateProcessEnv = (envList) => {
    if (!Array.isArray(envList))
        return;
    envList.forEach(({ title, value }) => {
        if (title) {
            process.env[title] = value;
        }
    });
};
exports.updateProcessEnv = updateProcessEnv;
//# sourceMappingURL=utils.js.map