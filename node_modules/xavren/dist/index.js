"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = void 0;
const fs_1 = __importDefault(require("fs"));
const chokidar_1 = __importDefault(require("chokidar"));
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config();
const utils_1 = require("./utils");
const state_1 = require("./state");
const websocket_1 = require("./websocket");
function watchEnv({ filePath = ".env", onChange, secretPhrase, key, }) {
    try {
        if (!fs_1.default.existsSync(filePath)) {
            console.warn(`⚠️  Env file not found at path: ${filePath}`);
        }
        const watcher = chokidar_1.default.watch(filePath, { persistent: true });
        watcher.on("change", (path) => {
            try {
                if (onChange) {
                    const content = fs_1.default.readFileSync(path, "utf8"); // read file content
                    onChange(content, path);
                }
            }
            catch (err) {
                console.warn(`⚠️  Failed to read env file: ${err.message || err}`);
            }
        });
        watcher.on("error", (err) => {
            console.warn(`⚠️  Watcher error: ${err.message || err}`);
        });
        return watcher; // return watcher in case you want to close it later
    }
    catch (e) {
    }
}
// const readandsave
const mount = async ({ path, secretPhrase, key, sync, project, fetchproject, }) => {
    const content = fs_1.default.readFileSync(path, "utf8");
    await onChange({ content, secretPhrase, key, sync, project, fetchproject });
};
const onChange = async ({ content, secretPhrase, key, sync, project, fetchproject, }) => {
    let c = (0, utils_1.parseAndUniqueEnv)(content);
    await (0, utils_1.addEnv)({ key: fetchproject, secretPhrase, sync, body: c, project });
};
const readenv = () => {
    let path = state_1.sessionStore.getState().config.envfile;
    const content = fs_1.default.readFileSync(path, "utf8");
    let c = (0, utils_1.parseAndUniqueEnv)(content);
    return c;
};
const setinitalEnv = () => {
    let c = readenv();
    state_1.envStore.getState().setEnvs(c);
};
const config = async ({ authPhrase, updateCloud = true, projectKey, env = ".env", sync = false, onSync = () => { }, omit = [] }) => {
    const [secretPhrase, email] = authPhrase.split("_kk_");
    state_1.sessionStore.getState().setSecretPhrase(secretPhrase);
    state_1.sessionStore.getState().setEmail(email);
    const [keyy, project] = projectKey.split("_kk_");
    let fetchproject = await (0, utils_1.getProjectById)(project);
    state_1.sessionStore.getState().setProject(fetchproject.data);
    state_1.sessionStore
        .getState()
        .setConfig({ envfile: env, sync, projectKey, authPhrase, onSync, omit, updateCloud });
    setinitalEnv();
    let socket = new websocket_1.SocketClient();
    if (fetchproject?.success) {
        socket.socket.emit("joinproject", { project: project });
    }
    else {
        console.warn("Invalid project");
        return;
    }
    await (0, utils_1.getEnvs)({ project: project, key: fetchproject.data });
    await mount({
        path: env,
        secretPhrase,
        key: keyy,
        sync,
        project,
        fetchproject: fetchproject.data,
    });
    watchEnv({
        onChange: async (content) => {
            await onChange({
                content,
                secretPhrase,
                key: keyy,
                sync,
                project,
                fetchproject: fetchproject.data,
            });
        },
        secretPhrase,
    });
    let getEnvs_ = () => {
        let envs = state_1.envStore.getState().envs;
        return (0, utils_1.getenvObject)(envs);
    };
    return {
        getEnvs: getEnvs_
    };
};
exports.config = config;
//# sourceMappingURL=index.js.map